Perfecto, he analizado ambos documentos y la estructura del proyecto Angular. Te proporciono el prompt completo y adaptado para implementar el sistema de autenticaci√≥n en Angular que se integre perfectamente con tu backend FastAPI:

üîê PROMPT COMPLETO PARA SISTEMA DE AUTENTICACI√ìN ANGULAR
üìã CONTEXTO DEL PROYECTO
Backend FastAPI Disponible:
URL Base: https://ia-legal-backend-ferhaaz.replit.app/api/v1
Endpoints implementados:
POST /auth/register - Registro de usuarios
POST /auth/login - Login con JWT
GET /auth/me - Perfil del usuario actual
PUT /auth/me - Actualizar perfil
PUT /auth/me/password - Cambiar contrase√±a
GET /auth/verify-token - Verificar token v√°lido
Estructura Angular Existente:
src/app/
‚îú‚îÄ‚îÄ authentication/
‚îÇ   ‚îú‚îÄ‚îÄ signin/               # ‚úÖ Ya existe - ADAPTAR
‚îÇ   ‚îú‚îÄ‚îÄ signup/               # ‚úÖ Ya existe - ADAPTAR
‚îÇ   ‚îî‚îÄ‚îÄ auth.routes.ts
‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îú‚îÄ‚îÄ service/auth.service.ts    # ‚úÖ Modificar para API real
‚îÇ   ‚îú‚îÄ‚îÄ guard/auth.guard.ts        # ‚úÖ Ya funciona
‚îÇ   ‚îî‚îÄ‚îÄ models/user.ts             # ‚úÖ Actualizar modelo
‚îú‚îÄ‚îÄ modules/dashboard/
‚îÇ   ‚îú‚îÄ‚îÄ dashboard.component.ts     # ‚úÖ P√°gina principal tras login
‚îÇ   ‚îî‚îÄ‚îÄ me/                        # üÜï CREAR - Perfil usuario
‚îú‚îÄ‚îÄ layout/
‚îÇ   ‚îú‚îÄ‚îÄ sidebar/                   # ‚úÖ Ya existe
‚îÇ   ‚îî‚îÄ‚îÄ header/                    # ‚úÖ Ya existe
‚îî‚îÄ‚îÄ shared/
    ‚îî‚îÄ‚îÄ interceptors/              # üÜï CREAR - JWT interceptor
üéØ IMPLEMENTACI√ìN REQUERIDA
1. ACTUALIZAR MODELO DE USUARIO
// src/app/core/models/user.ts
export interface User {
  id: string;
  email: string;
  username: string;
  full_name: string;
  position?: string;
  phone?: string;
  organization?: string;
  language: string;
  is_admin: boolean;
  is_active: boolean;
  created_at: string;
  updated_at: string;
}
export interface AuthResponse {
  access_token: string;
  refresh_token: string;
  token_type: string;
  expires_in: number;
  user: User;
}
export interface LoginRequest {
  email: string;
  password: string;
  remember_me: boolean;
}
export interface RegisterRequest {
  email: string;
  username: string;
  password: string;
  full_name: string;
  position?: string;
  phone?: string;
  organization?: string;
  language: string;
}
2. MODIFICAR AuthService PARA API REAL
// src/app/core/service/auth.service.ts
import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { BehaviorSubject, Observable, throwError } from 'rxjs';
import { map, catchError, tap } from 'rxjs/operators';
import { User, AuthResponse, LoginRequest, RegisterRequest } from '../models/user';
@Injectable({
  providedIn: 'root'
})
export class AuthService {
  private API_URL = 'https://ia-legal-backend-ferhaaz.replit.app/api/v1/auth';
  private currentUserSubject: BehaviorSubject<User | null>;
  public currentUser: Observable<User | null>;
  constructor(private http: HttpClient) {
    const storedUser = localStorage.getItem('currentUser');
    this.currentUserSubject = new BehaviorSubject<User | null>(
      storedUser ? JSON.parse(storedUser) : null
    );
    this.currentUser = this.currentUserSubject.asObservable();
  }
  public get currentUserValue(): User | null {
    return this.currentUserSubject.value;
  }
  login(loginData: LoginRequest): Observable<AuthResponse> {
    return this.http.post<AuthResponse>(`${this.API_URL}/login`, loginData)
      .pipe(
        tap(response => {
          // Guardar token
          localStorage.setItem('access_token', response.access_token);
          localStorage.setItem('refresh_token', response.refresh_token);
          
          // Guardar usuario si remember_me est√° activado
          if (loginData.remember_me) {
            localStorage.setItem('currentUser', JSON.stringify(response.user));
          } else {
            sessionStorage.setItem('currentUser', JSON.stringify(response.user));
          }
          
          this.currentUserSubject.next(response.user);
        }),
        catchError(this.handleError)
      );
  }
  register(registerData: RegisterRequest): Observable<any> {
    return this.http.post(`${this.API_URL}/register`, registerData)
      .pipe(catchError(this.handleError));
  }
  logout(): void {
    localStorage.removeItem('currentUser');
    localStorage.removeItem('access_token');
    localStorage.removeItem('refresh_token');
    sessionStorage.removeItem('currentUser');
    this.currentUserSubject.next(null);
  }
  getCurrentUser(): Observable<User> {
    return this.http.get<User>(`${this.API_URL}/me`)
      .pipe(catchError(this.handleError));
  }
  updateProfile(userData: Partial<User>): Observable<User> {
    return this.http.put<User>(`${this.API_URL}/me`, userData)
      .pipe(
        tap(user => {
          const storage = localStorage.getItem('currentUser') ? localStorage : sessionStorage;
          storage.setItem('currentUser', JSON.stringify(user));
          this.currentUserSubject.next(user);
        }),
        catchError(this.handleError)
      );
  }
  changePassword(passwordData: { current_password: string; new_password: string }): Observable<any> {
    return this.http.put(`${this.API_URL}/me/password`, passwordData)
      .pipe(catchError(this.handleError));
  }
  verifyToken(): Observable<any> {
    return this.http.get(`${this.API_URL}/verify-token`)
      .pipe(catchError(this.handleError));
  }
  isAuthenticated(): boolean {
    const token = localStorage.getItem('access_token');
    return !!token && !!this.currentUserValue;
  }
  private handleError(error: any) {
    let errorMessage = 'Ha ocurrido un error';
    
    if (error.error?.detail) {
      errorMessage = error.error.detail;
    } else if (error.status === 401) {
      errorMessage = 'Credenciales incorrectas';
    } else if (error.status === 400) {
      errorMessage = 'Datos inv√°lidos';
    } else if (error.status === 422) {
      errorMessage = 'Error de validaci√≥n';
    }
    
    return throwError(() => new Error(errorMessage));
  }
}
3. CREAR JWT INTERCEPTOR
// src/app/core/interceptors/jwt.interceptor.ts
import { Injectable } from '@angular/core';
import { HttpRequest, HttpHandler, HttpEvent, HttpInterceptor } from '@angular/common/http';
import { Observable } from 'rxjs';
import { AuthService } from '../service/auth.service';
@Injectable()
export class JwtInterceptor implements HttpInterceptor {
  constructor(private authService: AuthService) {}
  intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    const token = localStorage.getItem('access_token');
    const isApiUrl = request.url.startsWith('https://ia-legal-backend-ferhaaz.replit.app');
    
    if (token && isApiUrl) {
      request = request.clone({
        setHeaders: {
          Authorization: `Bearer ${token}`
        }
      });
    }
    return next.handle(request);
  }
}
4. CREAR ERROR INTERCEPTOR
// src/app/core/interceptors/error.interceptor.ts
import { Injectable } from '@angular/core';
import { HttpRequest, HttpHandler, HttpEvent, HttpInterceptor, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { AuthService } from '../service/auth.service';
import { Router } from '@angular/router';
@Injectable()
export class ErrorInterceptor implements HttpInterceptor {
  constructor(private authService: AuthService, private router: Router) {}
  intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    return next.handle(request).pipe(
      catchError((error: HttpErrorResponse) => {
        if (error.status === 401) {
          // Token expirado o inv√°lido
          this.authService.logout();
          this.router.navigate(['/authentication/signin']);
        }
        
        return throwError(() => error);
      })
    );
  }
}
5. ACTUALIZAR FORMULARIO DE LOGIN
// src/app/authentication/signin/signin.component.ts
import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { Router } from '@angular/router';
import { AuthService } from '../../core/service/auth.service';
@Component({
  selector: 'app-signin',
  templateUrl: './signin.component.html',
  styleUrls: ['./signin.component.scss']
})
export class SigninComponent implements OnInit {
  loginForm: FormGroup;
  loading = false;
  submitted = false;
  error = '';
  constructor(
    private formBuilder: FormBuilder,
    private authService: AuthService,
    private router: Router
  ) {}
  ngOnInit(): void {
    this.loginForm = this.formBuilder.group({
      email: ['', [Validators.required, Validators.email]],
      password: ['', [Validators.required, Validators.minLength(8)]],
      remember_me: [false]
    });
  }
  get f() { return this.loginForm.controls; }
  onSubmit(): void {
    this.submitted = true;
    this.error = '';
    if (this.loginForm.invalid) {
      return;
    }
    this.loading = true;
    this.authService.login(this.loginForm.value).subscribe({
      next: (response) => {
        this.router.navigate(['/dashboard']);
      },
      error: (error) => {
        this.error = error.message;
        this.loading = false;
      }
    });
  }
}
6. ACTUALIZAR FORMULARIO DE REGISTRO
// src/app/authentication/signup/signup.component.ts
import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators, AbstractControl } from '@angular/forms';
import { Router } from '@angular/router';
import { AuthService } from '../../core/service/auth.service';
@Component({
  selector: 'app-signup',
  templateUrl: './signup.component.html',
  styleUrls: ['./signup.component.scss']
})
export class SignupComponent implements OnInit {
  registerForm: FormGroup;
  loading = false;
  submitted = false;
  error = '';
  constructor(
    private formBuilder: FormBuilder,
    private authService: AuthService,
    private router: Router
  ) {}
  ngOnInit(): void {
    this.registerForm = this.formBuilder.group({
      email: ['', [Validators.required, Validators.email]],
      username: ['', [Validators.required, Validators.pattern(/^[a-zA-Z0-9_]+$/)]],
      password: ['', [Validators.required, this.passwordValidator]],
      confirm_password: ['', Validators.required],
      full_name: ['', Validators.required],
      position: [''],
      phone: [''],
      organization: [''],
      language: ['es', Validators.required]
    }, { validators: this.passwordMatchValidator });
  }
  passwordValidator(control: AbstractControl): {[key: string]: any} | null {
    const password = control.value;
    const hasUpperCase = /[A-Z]/.test(password);
    const hasLowerCase = /[a-z]/.test(password);
    const hasNumbers = /\d/.test(password);
    const hasMinLength = password && password.length >= 8;
    const valid = hasUpperCase && hasLowerCase && hasNumbers && hasMinLength;
    return valid ? null : { invalidPassword: true };
  }
  passwordMatchValidator(group: AbstractControl): {[key: string]: any} | null {
    const password = group.get('password');
    const confirmPassword = group.get('confirm_password');
    
    if (password?.value !== confirmPassword?.value) {
      confirmPassword?.setErrors({ passwordMismatch: true });
      return { passwordMismatch: true };
    }
    return null;
  }
  get f() { return this.registerForm.controls; }
  onSubmit(): void {
    this.submitted = true;
    this.error = '';
    if (this.registerForm.invalid) {
      return;
    }
    this.loading = true;
    const formData = { ...this.registerForm.value };
    delete formData.confirm_password;
    this.authService.register(formData).subscribe({
      next: () => {
        this.router.navigate(['/authentication/signin'], {
          queryParams: { message: 'Registro exitoso. Inicia sesi√≥n.' }
        });
      },
      error: (error) => {
        this.error = error.message;
        this.loading = false;
      }
    });
  }
}
7. CREAR COMPONENTE DE PERFIL
// src/app/modules/dashboard/me/me.component.ts
import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { AuthService } from '../../../core/service/auth.service';
import { User } from '../../../core/models/user';
@Component({
  selector: 'app-me',
  templateUrl: './me.component.html',
  styleUrls: ['./me.component.scss']
})
export class MeComponent implements OnInit {
  user: User | null = null;
  profileForm: FormGroup;
  passwordForm: FormGroup;
  loading = false;
  message = '';
  activeTab = 'profile';
  constructor(
    private formBuilder: FormBuilder,
    private authService: AuthService
  ) {}
  ngOnInit(): void {
    this.user = this.authService.currentUserValue;
    this.initializeForms();
  }
  initializeForms(): void {
    this.profileForm = this.formBuilder.group({
      full_name: [this.user?.full_name || '', Validators.required],
      position: [this.user?.position || ''],
      phone: [this.user?.phone || ''],
      organization: [this.user?.organization || ''],
      language: [this.user?.language || 'es', Validators.required]
    });
    this.passwordForm = this.formBuilder.group({
      current_password: ['', Validators.required],
      new_password: ['', [Validators.required, Validators.minLength(8)]],
      confirm_password: ['', Validators.required]
    }, { validators: this.passwordMatchValidator });
  }
  passwordMatchValidator(group: any): {[key: string]: any} | null {
    const newPassword = group.get('new_password');
    const confirmPassword = group.get('confirm_password');
    
    if (newPassword?.value !== confirmPassword?.value) {
      return { passwordMismatch: true };
    }
    return null;
  }
  updateProfile(): void {
    if (this.profileForm.valid) {
      this.loading = true;
      this.authService.updateProfile(this.profileForm.value).subscribe({
        next: (user) => {
          this.user = user;
          this.message = 'Perfil actualizado exitosamente';
          this.loading = false;
        },
        error: (error) => {
          this.message = error.message;
          this.loading = false;
        }
      });
    }
  }
  changePassword(): void {
    if (this.passwordForm.valid) {
      this.loading = true;
      const { current_password, new_password } = this.passwordForm.value;
      
      this.authService.changePassword({ current_password, new_password }).subscribe({
        next: () => {
          this.message = 'Contrase√±a cambiada exitosamente';
          this.passwordForm.reset();
          this.loading = false;
        },
        error: (error) => {
          this.message = error.message;
          this.loading = false;
        }
      });
    }
  }
}
8. CONFIGURAR INTERCEPTORS EN APP MODULE
// src/app/app.module.ts o app.config.ts
import { HTTP_INTERCEPTORS } from '@angular/common/http';
import { JwtInterceptor } from './core/interceptors/jwt.interceptor';
import { ErrorInterceptor } from './core/interceptors/error.interceptor';
// En providers array:
providers: [
  {
    provide: HTTP_INTERCEPTORS,
    useClass: JwtInterceptor,
    multi: true
  },
  {
    provide: HTTP_INTERCEPTORS,
    useClass: ErrorInterceptor,
    multi: true
  }
]
9. ACTUALIZAR RUTAS PARA PERFIL
// src/app/modules/dashboard/dashboard.routes.ts
import { Routes } from '@angular/router';
import { MeComponent } from './me/me.component';
export const DashboardRoutes: Routes = [
  { path: '', component: DashboardComponent },
  { path: 'me', component: MeComponent }
];
üéØ FUNCIONALIDADES IMPLEMENTADAS
‚úÖ Sistema Completo de Autenticaci√≥n:
Login con email/password y remember_me
Registro con validaciones completas
Gesti√≥n de tokens JWT autom√°tica
Interceptores para manejo de errores y autenticaci√≥n
Rutas protegidas con AuthGuard existente
‚úÖ Gesti√≥n de Perfil:
Componente de perfil integrado en dashboard
Actualizaci√≥n de datos personales
Cambio de contrase√±a con validaci√≥n
Persistencia de sesi√≥n configurada
‚úÖ Integraci√≥n con Backend:
Todas las llamadas a la API real de FastAPI
Manejo de errores HTTP espec√≠ficos
Tokens JWT en headers autom√°ticos
Validaciones que coinciden con el backend
‚úÖ UX/UI Profesional:
Estados de carga en formularios
Validaciones en tiempo real
Mensajes de error espec√≠ficos
Navegaci√≥n fluida entre componentes
Aprovecha la estructura existente del proyecto
üöÄ PASOS PARA IMPLEMENTAR
Actualizar modelo User con la nueva estructura
Modificar AuthService para conectar con API real
Crear interceptors JWT y Error
Actualizar formularios signin/signup con validaciones
Crear componente de perfil (/me)
Configurar interceptors en app module
Actualizar rutas para incluir perfil
Testear integraci√≥n completa con backend
Este sistema aprovecha toda la infraestructura existente de Angular y se integra perfectamente con tu backend FastAPI, manteniendo la estructura modular y profesional del proyecto.